# Customise this file, documentation can be found here:
# https://github.com/fastlane/fastlane/tree/master/fastlane/docs
# All available actions: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Actions.md
# can also be listed using the `fastlane actions` command

# Change the syntax highlighting to Ruby
# All lines starting with a # are ignored when running `fastlane`

# If you want to automatically update fastlane if a new version is available:
# update_fastlane

#
# This file was created by the help of https://gist.github.com/ulhas/e8e529d08849b8cda947
#

# NOTE: To use faslane install:
#           gem install bundler 
#           brew install git-flow
#           brew install appledoc
#
#     Git-flow witll be configured upon installation or the first run of fastlane.
#     IMPORTANT: Use the default options !!!
#
#   and then run:
#           bundle exec fastlane release bump_type:"minor"

# This is the minimum version number required. 
# Update this, if you use features of a newer version.
fastlane_version "2.105.2"

default_platform :ios

before_all do
  # This block is called, before execute the lane
end


after_all do |lane|
  # This block is called, only if the executed lane was successful
end


error do |lane, exception|
  # Reset builld/version number increment after failed release
  sh "git reset --hard HEAD"
end


###############################################################################
#                          PUBLIC SECTION
###############################################################################

desc "Creates a release branch"
desc "Runs framework tests"
desc "Increments framework number"
desc "Updates podspec file"
desc "Pushes podspec file to Cocoapods"
desc "Pushes releases to github"
desc "Commits and pushes changes to remote and tags the release commit"
lane :release do |options|

  config = project_configuration
  framework = config["name"]
  repo_name = "blackjacx/#{framework}"
  homebrew_formula_name = options[:formula]

  UI.user_error!("No framework name found") unless is_set( framework )

  # Ensure the source code is OK and tests are green
  ensure_bundle_exec
  ensure_git_status_clean
  ensure_git_branch(branch: "develop")
  
  # Delete local branches and tags not on remote to prevent pushing unwanted tags
  sh "git fetch --prune --prune-tags"
  # Pull develop/main to be sure we're up to date everywherre
  sh "git pull && git checkout main && git pull && git checkout develop"

  if has_project_file
    bump_type = options[:bump_type]
    UI.user_error!("bump_type not specified. Please specify \"major\", \"minor\" or \"patch\"!") unless is_set( bump_type )

    # Sets CFBundleShortVersionString"
    version = increment_version_number(xcodeproj: "#{framework}.xcodeproj", bump_type: bump_type)
    UI.user_error!("No version number generated by bump") unless is_set( version )
    UI.user_error!("Git tag #{version} already exists") if git_tag_exists(tag: version)

    # Increment CFBundleVersion by one
    build_number = increment_build_number(xcodeproj: "#{framework}.xcodeproj")
    UI.user_error!("No build number generated by bump") unless is_set( build_number )
  else
    version = options[:version]
    UI.user_error!("version not specified. Please specify a semantic version \"x.x.x\"!") unless is_set( version )
  end

  # Check if Github release exists
  github_release = get_github_release(url: repo_name, version: version).
  UI.user_error!("Github release #{version} already exists") if is_set( github_release )

  # Updates framework podspec version
  version_bump_podspec(path: "#{framework}.podspec", version_number: version) if is_cocoapods_framework

  update_mit_license

  # Read the "Unreleased" changelog section
  changelog = read_changelog(
    section_identifier: '[Unreleased]', # Specify what section to read
    excluded_markdown_elements: []  # Specify which markdown elements should be excluded
  )

  # Write the changelog to a new section named with the release version
  stamp_changelog(
    section_identifier: version # Stamp Unreleased section with newly released build number
  )


  # Check if Podspec is OK and tests succeed
  pod_lib_lint(allow_warnings: true) if is_cocoapods_framework
  test

  # Build documentation
  sh "cd .. && ./scripts/make-docc-documentation.sh #{framework}"

  #
  # Start the release
  #

  release_branch = "release/#{version}"

  sh "git checkout -b #{release_branch}"
  sh "git commit -am 'Fastlane: Release on Production #{version}'"

  # Finish the release branch. The shell may hang here because it: 
  # 1) prompts for a merge message.
  # 
  # To get around this do the following:
  # 1) git config --global core.mergeoptions --no-edit
  tag_message = "production_release_#{version}"
  sh "git checkout main"
  sh "git merge --no-ff #{release_branch}"
  sh "git tag -m #{tag_message} -a #{version}"
  sh "git checkout develop"
  sh "git merge --no-ff #{release_branch}"
  sh "git branch -d #{release_branch}"

  sh "git push origin develop"
  sh "git push origin main"
  sh "git push origin -f --tags"

  # Pushes framework podspec to Cocoapods specs
  # Needs to be done at the end (expects git tag to be available)
  pod_push(path: "#{framework}.podspec", allow_warnings: true) if is_cocoapods_framework

  # Create a Carthage archive which is then added to the github release, to enable carthage caching
  github_release_assets = []

  if has_project_file
    # Pre-build Carthage artifacts - for ALL: frameworks, packages, ...
    xcframework_name = "#{framework}.xcframework"
    archive_name = "#{xcframework_name}.zip"
    sh "cd .. && mint run carthage carthage build --no-skip-current --use-xcframeworks" 
    # change to the carthage builds folder and zip the contents so only <framework>.xcframework is in the zip
    sh "cd .. && pushd Carthage/Build && zip -r0 ../../#{archive_name} #{xcframework_name} && popd"
    github_release_assets.append("#{archive_name}")
  end

  # Creates new release on Github with changelog + pushes the tag if not done already
  set_github_release(
    repository_name: repo_name,
    api_token: ENV["GITHUB_TOKEN"],
    name: version,
    tag_name: version,
    is_generate_release_notes: true,
    commitish: "main",
    upload_assets: github_release_assets,
  )

  if is_set( homebrew_formula_name ) && is_set( lane_context[SharedValues::SET_GITHUB_RELEASE_HTML_LINK] )
    UI.important("Bumping Homebrew tap \"#{homebrew_formula_name}\" with version #{version}")
    sh "brew bump-formula-pr --no-audit --message=\"Update Formula #{version}\" --tag=\"#{version}\" --revision=$(git rev-list -n 1 #{version}) #{homebrew_formula_name}"
  end
end

desc "Runs tests using scan"
lane :test do |options|
  config = project_configuration
  framework = config["name"]
  schemes = config["schemes"]
  platforms = ["iOS", "tvOS", "watchOS", "macOS"]

  if is_set( framework ) 
    UI.important("Found framework name: #{framework}")
  else 
    UI.user_error!("No framework name found")
  end  

  if schemes.length > 0 
    UI.important("Found schemes: #{schemes}")
  else
    UI.user_error!("No schemes found")
  end  

  # only run the cocoapods action if there is a podfile
  cocoapods(repo_update: true) if has_podfile

  if is_pure_spm_package
    scheme = framework
    supported_platforms = spm_supported_platforms
    # destinations = sh "cd .. && xcodebuild -showdestinations -scheme #{scheme} -json" # only works if we have a workspace

    # supports_ios = supported_platforms.include? "ios"
    # supports_tvos = supported_platforms.include? "tvos"
    # supports_watchos = supported_platforms.include? "watchos"
    # supports_macos = supported_platforms.include? "macos"

    # sh "cd .. && xcodebuild -scheme #{scheme} test -sdk iphonesimulator -destination 'platform=iOS Simulator,name=iPhone 12 Pro'" if supports_ios
    # sh "cd .. && xcodebuild -scheme #{scheme} test -sdk appletvsimulator -destination 'platform=tvOS Simulator,name=Apple TV'" if supports_tvos
    # sh "cd .. && xcodebuild -scheme #{scheme} test -sdk watchsimulator -destination 'platform=watchOS Simulator,name=Apple Watch Series 6 - 44mm'" if supports_watchos
    # sh "cd .. && xcodebuild -scheme #{scheme} test -sdk macosx -destination 'platform=macOS'" if supports_macos
  end

  if is_cocoapods_framework    
    xargs = "-maximum-parallel-testing-workers 1 -parallel-testing-enabled NO -maximum-concurrent-test-simulator-destinations 1 -disable-concurrent-destination-testing"    
    
    schemes.each do |scheme|
      scan(scheme: scheme, clean: true, xcargs: xargs) if scheme.include? "#{framework}" # don't test schemes like `Resources-iOS` in Columbus
    end
  end

  danger(verbose: true) if is_true( options[:run_danger] )
end


###############################################################################
#                          PRIVATE SECTION
###############################################################################

desc "Updates the LICENSE file to MIT by replacing year and authors from a template file."
private_lane :update_mit_license do |options|
  fAuthors = "../AUTHORS"
  UI.user_error!("#{fAuthors} not found! Quit...") unless File.file?("#{fAuthors}")

  fLicense = "../LICENSE"
  UI.user_error!("#{fLicense} not found! Quit...") unless File.file?("#{fLicense}")

  authors = File.read("#{fAuthors}")
    .gsub(/\n/, ", ")

  data = download(url: "https://raw.githubusercontent.com/Blackjacx/Scripts/main/LICENSE_MIT")
    .gsub(/<year>/, "#{Time.now.year}")
    .gsub(/<copyright holders>/, "#{authors}")

  newFile = File.open("#{fLicense}", "w")
  newFile.write(data)
  newFile.close
end


###############################################################################
# Playground
###############################################################################

desc "An contained area for testing new features or running parts of other lanes."
lane :playground do |o|
  
  config = project_configuration
  framework = config["name"]
  schemes = config["schemes"]
  platforms = spm_supported_platforms
  UI.user_error!("No framework name found") unless is_set( framework )
  UI.user_error!("No schemes found") unless schemes.length > 0
  UI.user_error!("No platforms found") unless platforms.length > 0
  
  puts framework
  puts schemes
  puts platforms

  #
  # How to test my frameworks
  #

  # For Swift packages
  sh "cd .. && xcodebuild -list -json | jq" # get all schemes
  sh "cd .. && swift package dump-package | jq '.platforms'" # get supported platforms
  sh "cd .. && xcrun simctl list --json | jq" # get simulator name per platform
  # for each scheme test for each platform using xcodebuild

  # For Xcode projects


  sh "cd .. && xcodebuild -showdestinations -scheme #{scheme} -json"
  
  sh "cd .. && xcrun simctl list --json | jq" # promising but doesn't relate to scheme
  sh "cd .. && xcodebuild -list -json | jq" # good to get all schemes
  sh "cd .. && swift package dump-package | jq '.platforms'" # needed for SPM to get supported platforms

  sh "cd .. && xcrun xctrace list devices" # not suitable sine outputs all simulators

  #
  # Build Carthage pre-built framework for Github
  #

  # # Pre-build Carthage artifacts - for ALL: frameworks, packages, ...
  # xcframework_name = "#{framework}.xcframework"
  # archive_name = "#{xcframework_name}.zip"
  # sh "cd .. && carthage build --no-skip-current --use-xcframeworks" 
  # # change to the carthage builds folder and zip the contents so only <framework>.xcframework is in the zip
  # sh "cd .. && pushd Carthage/Build && zip -r0 ../../#{archive_name} #{xcframework_name} && popd"
end


###############################################################################
# Global Functions
###############################################################################

def is_true(var)
  !var.nil? && !var.to_s.strip.empty? && var != "0" && (var == "pull_request" || var == "1" || var == "true")
end

def is_set(var)
  !var.nil? && !var.to_s.strip.empty? && var != "0"
end

def is_cocoapods_framework
  podspecs = Dir["../*.podspec"]
  return podspecs.count == 1
end

def has_podfile
  podfile = Dir["../Podfile"]
  return podfile.count == 1
end

def is_carthage_framework
  File.file?("../Cartfile")
end

def is_pure_spm_package
  File.file?("../Package.swift") && !is_cocoapods_framework
end

def has_project_file
  project = Dir["../*.xcodeproj"]
  return project.count == 1
end

def project_configuration
  config = JSON.parse("#{sh 'cd .. && xcrun xcodebuild -quiet -list -json 1>&2 2>/dev/null'}")
  config = has_project_file ? config["project"] : config["workspace"]
  return config
end

def spm_supported_platforms
  # jq '.platforms[].platformName'
  package = JSON.parse("#{sh 'cd .. && swift package dump-package'}")
  platforms = package["platforms"]
  platform_names = platforms.map { |platform| platform["platformName"] }
  # platform_versions = platforms.map { |platform| platform["version"] }
  return platform_names
end














